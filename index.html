<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MidBar Finder</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet.js CSS & JS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      crossorigin=""
    ></script>

    <style>
      /* ===============================
         GLOBAL BASE STYLES
      =============================== */
      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: linear-gradient(135deg, #e2bb0c 0%, #ff7b00 100%);
        color: #1f2937;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .glass-panel {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 1rem;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
      }

      /* ===============================
         MAP ELEMENTS
      =============================== */
      #map {
        position: absolute;
        inset: 0;
        height: 100%;
        width: 100%;
        z-index: 10;
      }

      .emoji-marker {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .emoji-marker-bg {
        background: rgba(255, 255, 255, 0.95);
        border: 2px solid #333;
        border-radius: 50%;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .emoji-marker-bg:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      }

      .emoji-marker-bar {
        font-size: 30px;
      }

      /* ===============================
         BUTTONS
      =============================== */
      button {
        border: none;
        outline: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-primary {
        width: 100%;
        padding: 0.75rem 1.25rem;
        background: linear-gradient(to right, #10b981, #059669);
        color: white;
        font-weight: 600;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
      }

      .btn-primary:hover {
        transform: scale(1.03);
        background: linear-gradient(to right, #059669, #047857);
      }

      .btn-calculate {
        width: 100%;
        height: 3.5rem;
        margin-top: 2rem;
        background: linear-gradient(to right, #e2bb0c, #ff7b00);
        color: white;
        font-weight: 700;
        font-size: 1.125rem;
        border-radius: 0.75rem;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
      }

      .btn-calculate:hover {
        transform: scale(1.03);
        box-shadow: 0 20px 30px rgba(0, 0, 0, 0.15);
      }

      /* Navigation buttons (on map) */
      .nav-button {
        padding: 0.375rem 0.75rem;
        background-color: #e5e7eb;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        font-weight: 600;
      }

      .nav-button:hover {
        background-color: #d1d5db;
      }

      /* Back button */
      #backButton {
        background-color: #1f2937;
        color: white;
        font-weight: 600;
        border-radius: 0.75rem;
        padding: 0.75rem 1.5rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
      }

      #backButton:hover {
        background-color: #111827;
      }

      /* ===============================
         INPUTS AND CARDS
      =============================== */
      .input-field {
        width: 100%;
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        border: 2px solid #e5e7eb;
        transition: all 0.2s;
      }

      .input-field:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
      }

      .interactive-card {
        padding: 0.75rem;
        border-radius: 0.5rem;
        border: 2px solid #e5e7eb;
        cursor: pointer;
        transition: all 0.2s;
      }

      .interactive-card:hover {
        border-color: #93c5fd;
        background-color: #eff6ff;
      }

      .section-divider {
        margin-top: 2rem;
        padding-top: 1.5rem;
        border-top: 2px solid #e5e7eb;
      }

      /* ===============================
         STRATEGY TOGGLES
      =============================== */
      /* Map toggles */
      .strategy-toggle {
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        font-weight: 600;
        font-size: 0.85rem;
        transition: all 0.2s;
      }

      .strategy-toggle.active {
        background: #3b82f6;
        color: white;
      }

      .strategy-toggle:not(.active) {
        background: #f3f4f6;
        color: #374151;
      }

      .strategy-toggle:not(.active):hover {
        background: #e5e7eb;
      }

      /* ===============================
         LOADING SPINNER
      =============================== */
      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-left-color: #ffffff;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* ===============================
         MOBILE RESPONSIVENESS
      =============================== */
      @media (max-width: 768px) {
        body {
          font-size: 0.9rem;
        }

        .glass-panel {
          font-size: 0.9rem;
        }

        #backButton {
          font-size: 0.9rem;
          position: fixed;
          bottom: 1rem;
          left: 1rem;
          padding: 0.6rem 1rem;
        }

        #strategyToggleContainer {
          flex-direction: column;
          position: fixed;
          bottom: 1rem;
          right: 1rem;
          padding: 0.75rem;
          border-radius: 0.75rem;
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .strategy-toggle {
          font-size: 0.8rem;
          padding: 0.5rem;
        }

        .btn-calculate {
          font-size: 1rem;
          height: 3rem;
        }

        .interactive-card {
          padding: 0.5rem;
        }
      }
    </style>
  </head>

  <body class="h-screen w-screen overflow-hidden flex flex-col antialiased">
    <!-- Input View -->
    <div id="inputView" class="p-4 overflow-y-auto">
      <div class="max-w-2xl mx-auto glass-panel p-6 rounded-2xl shadow-2xl">
        <header class="text-center mb-6">
          <h1 class="text-3xl font-bold text-gray-800 mb-2">üçª MidBar Finder</h1>
          <p class="text-gray-600">Find the perfect central meeting spot for your group</p>
        </header>

        <label for="generalLocation" class="block text-sm font-semibold text-gray-700 mb-2">
          General Location
        </label>
        <input type="text" id="generalLocation" class="input-field" placeholder="e.g., Z√ºrich" />
        <p class="text-xs text-gray-500 mt-1 mb-6">Optional: Adds context to each person's location</p>

        <div id="peopleContainer" class="mb-6"></div>

        <button id="addPersonButton" class="btn-primary">+ Add Person</button>

        <div class="section-divider">
          <h2 class="font-bold text-lg mb-3">Optimization Strategy</h2>
          <label class="interactive-card flex items-start">
            <input type="radio" name="strategy" value="utilitarianism" class="mt-1 h-4 w-4 text-blue-600" checked />
            <div class="ml-3">
              <span class="font-bold text-gray-800">Utilitarianism</span>
              <p class="text-sm text-gray-600">Minimize total travel distance for the group</p>
            </div>
          </label>

          <label class="interactive-card flex items-start">
            <input type="radio" name="strategy" value="socialism" class="mt-1 h-4 w-4 text-blue-600" />
            <div class="ml-3">
              <span class="font-bold text-gray-800">Socialism</span>
              <p class="text-sm text-gray-600">Minimize squared distances (fairer to outliers)</p>
            </div>
          </label>

          <label class="interactive-card flex items-start">
            <input type="radio" name="strategy" value="communism" class="mt-1 h-4 w-4 text-blue-600" />
            <div class="ml-3">
              <span class="font-bold text-gray-800">Communism</span>
              <p class="text-sm text-gray-600">Find the most equidistant location</p>
            </div>
          </label>
        </div>

        <div class="section-divider">
          <label class="interactive-card flex items-center">
            <input id="includeRestaurants" type="checkbox" class="h-5 w-5 text-blue-600 rounded" />
            <span class="ml-3 font-semibold text-gray-800">Include Restaurants</span>
          </label>
        </div>

        <button id="calculateButton" class="btn-calculate">
          <span id="calcButtonText">Optimize</span>
          <div id="loadingSpinner" class="spinner hidden"></div>
        </button>
      </div>
    </div>

    <!-- Map View -->
    <div id="mapView" class="hidden relative flex-grow">
      <div id="map"></div>

      <div class="absolute inset-0 pointer-events-none z-30 p-3 flex flex-col">
        <div class="flex gap-2 mb-auto pointer-events-auto">
          <div class="glass-panel p-3 rounded-xl flex-1 min-w-0">
            <div class="flex items-center gap-2 mb-2">
              <button id="prevBarButton" class="nav-button">‚Üê</button>
              <span id="barRank" class="font-bold text-gray-700 text-center flex-grow">Best Location</span>
              <button id="nextBarButton" class="nav-button">‚Üí</button>
            </div>
            <h3 id="barName" class="font-bold text-gray-900 truncate"></h3>
          </div>

          <div class="glass-panel p-3 rounded-xl">
            <h3 id="totalDistanceStat" class="font-bold text-gray-900">0.00 km</h3>
            <h4 id="weightedDistanceStat" class="text-sm font-semibold text-gray-600">0.00 km¬≤</h4>
          </div>
        </div>

        <div class="flex flex-col sm:flex-row gap-2 justify-between pointer-events-auto">
          <button id="backButton">‚Üê Back</button>

          <div id="strategyToggleContainer" class="glass-panel p-2 rounded-xl flex gap-1.5">
            <button id="toggle_utilitarianism" class="strategy-toggle active" data-strategy="utilitarianism">
              Utilitarianism
            </button>
            <button id="toggle_socialism" class="strategy-toggle" data-strategy="socialism">
              Socialism
            </button>
            <button id="toggle_communism" class="strategy-toggle" data-strategy="communism">
              Communism
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Error Modal -->
    <div id="errorModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
      <div class="bg-white max-w-sm w-full p-6 rounded-xl shadow-2xl text-center">
        <div class="text-5xl mb-4">‚ö†Ô∏è</div>
        <h3 class="text-2xl font-bold text-red-600 mb-3">Oops!</h3>
        <p id="errorMessage" class="text-gray-700 mb-6"></p>
        <button id="closeErrorButton" class="w-full px-4 py-3 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700">
          Close
        </button>
      </div>
    </div>


    <script>
      // global variables
      let map;
      const mapLayers = [];
      const dynamicMapLayers = [];
      const peopleMarkers = [];
      const personEmojis = [
        "üòÄ",
        "üòé",
        "ü•≥",
        "üê±",
        "üê∂",
        "ü¶ä",
        "üêª",
        "üêº",
        "üê®",
        "üêØ",
        "üßë‚ÄçüöÄ",
        "ü¶∏",
        "ü•∑",
        "üßë‚Äçüíª",
        "üßë‚Äçüé®",
      ];

      let geocodedPeopleList = [];
      let allBars = [];
      const strategyResults = {
        utilitarianism: { bestBar: null, candidates: [], color: "#3b82f6" },
        socialism: { bestBar: null, candidates: [], color: "#ec4899" },
        communism: { bestBar: null, candidates: [], color: "#10b981" },
      };
      let currentRankIndex = 0;
      let currentStrategy = "utilitarianism";

      // ui refs
      const inputView = document.getElementById("inputView");
      const mapView = document.getElementById("mapView");
      const peopleContainer = document.getElementById("peopleContainer");
      const addPersonButton = document.getElementById("addPersonButton");
      const generalLocationInput = document.getElementById("generalLocation");
      const calculateButton = document.getElementById("calculateButton");
      const calcButtonText = document.getElementById("calcButtonText");
      const loadingSpinner = document.getElementById("loadingSpinner");
      const backButton = document.getElementById("backButton");
      const barName = document.getElementById("barName");
      const totalDistanceStat = document.getElementById("totalDistanceStat");
      const weightedDistanceStat = document.getElementById(
        "weightedDistanceStat"
      );
      const includeRestaurants = document.getElementById("includeRestaurants");
      const strategyToggleContainer = document.getElementById(
        "strategyToggleContainer"
      );

      // error modal
      const errorModal = document.getElementById("errorModal");
      const errorMessage = document.getElementById("errorMessage");
      const closeErrorButton = document.getElementById("closeErrorButton");

      // dom ready
      document.addEventListener("DOMContentLoaded", () => {
        addPersonInput();
        addPersonInput();
      });

      const prevBarButton = document.getElementById("prevBarButton");
      const nextBarButton = document.getElementById("nextBarButton");
      const barRank = document.getElementById("barRank");

      prevBarButton.onclick = () => changeBarRank(-1);
      nextBarButton.onclick = () => changeBarRank(1);

      addPersonButton.onclick = addPersonInput;
      calculateButton.onclick = findMidBar;
      backButton.onclick = resetApp;
      closeErrorButton.onclick = () => errorModal.classList.add("hidden");

      document.querySelectorAll(".strategy-toggle").forEach((button) => {
        button.onclick = (e) => {
          const s = e.currentTarget.dataset.strategy;
          currentStrategy = s;
          currentRankIndex = 0;
          showStrategyResults(s); // ensures button colors update
        };
      });

      function addPersonInput() {
        const personCount = peopleContainer.children.length;
        const emoji = personEmojis[personCount % personEmojis.length];

        const personDiv = document.createElement("div");
        personDiv.className =
          "flex items-center gap-3 p-3 bg-gray-50 rounded-lg border";

        personDiv.innerHTML = `
                <span class="text-2xl">${emoji}</span>
                <div class="flex-grow grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <input type="text" placeholder="Name (e.g., Alice)" class="w-full px-4 py-2 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" data-role="name">
                    <input type="text" placeholder="Location (e.g., Z√ºrich Paradeplatz)" class="w-full px-4 py-2 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500" data-role="location">
                </div>
                <button class="remove-person text-red-500 hover:text-red-700 font-bold text-2xl px-2" title="Remove person">&times;</button>
            `;

        const removeButton = personDiv.querySelector(".remove-person");
        removeButton.onclick = () => {
          if (peopleContainer.children.length > 2) {
            personDiv.remove();
          } else {
            showError("You need at least two people to find a midpoint.");
          }
        };

        peopleContainer.appendChild(personDiv);
      }

      async function findMidBar() {
        showLoading(true);
        strategyToggleContainer.classList.add("hidden");

        const peopleInputs = [];
        const inputDivs = peopleContainer.querySelectorAll("div");
        const generalLocation = generalLocationInput.value.trim();

        inputDivs.forEach((div, index) => {
          const nameInput = div.querySelector('input[data-role="name"]');
          const locationInput = div.querySelector(
            'input[data-role="location"]'
          );

          if (nameInput && locationInput && locationInput.value.trim() !== "") {
            let locationQuery = locationInput.value.trim();
            if (
              generalLocation !== "" &&
              locationQuery
                .toLowerCase()
                .indexOf(generalLocation.toLowerCase()) === -1
            ) {
              locationQuery = `${locationQuery}, ${generalLocation}`;
            }

            peopleInputs.push({
              name: nameInput.value.trim() || `Person ${index + 1}`,
              locationQuery: locationQuery,
              emoji: personEmojis[index % personEmojis.length],
            });
          }
        });

        if (peopleInputs.length < 2) {
          showError("Please enter locations for at least two people.");
          showLoading(false);
          return;
        }

        try {
          const geocodePromises = peopleInputs.map((p) =>
            geocodeLocation(p.locationQuery)
          );
          const geocodedResults = await Promise.all(geocodePromises);

          geocodedPeopleList = [];
          for (let i = 0; i < geocodedResults.length; i++) {
            const result = geocodedResults[i];
            if (!result) {
              throw new Error(
                `Could not find location for "${peopleInputs[i].locationQuery}"`
              );
            }
            geocodedPeopleList.push({
              ...peopleInputs[i],
              lat: result.location.lat,
              lng: result.location.lng,
            });
          }

          const lats = geocodedPeopleList.map((p) => p.lat);
          const lngs = geocodedPeopleList.map((p) => p.lng);

          const padding = 0.1;
          const bounds = {
            south: Math.min(...lats) - padding,
            west: Math.min(...lngs) - padding,
            north: Math.max(...lats) + padding,
            east: Math.max(...lngs) + padding,
          };

          const considerRestaurants = includeRestaurants.checked;
          allBars = await fetchBarsInBounds(bounds, considerRestaurants);

          if (allBars.length === 0) {
            throw new Error(
              "No bars or pubs found in the area between all people. Try a different location."
            );
          }

          const initialStrategy = document.querySelector(
            'input[name="strategy"]:checked'
          ).value;

          for (const bar of allBars) {
            const individualDistances = [];
            let totalDistance = 0;
            let weightedDistance = 0;

            for (const person of geocodedPeopleList) {
              const dist = haversineDistance(
                person.lat,
                person.lng,
                bar.lat,
                bar.lng
              );
              individualDistances.push(dist);
              totalDistance += dist;
              weightedDistance += dist * dist;
            }

            bar.totalDistance = totalDistance;
            bar.weightedDistance = weightedDistance;
            bar.individualDistances = individualDistances;

            const mean = totalDistance / individualDistances.length;
            let variance = 0;
            for (const dist of individualDistances) {
              variance += (dist - mean) * (dist - mean);
            }
            bar.distanceVariance = variance / individualDistances.length;
          }

          // find best bars and candidates
          Object.keys(strategyResults).forEach((strategyName) => {
            let sortedBars;
            switch (strategyName) {
              case "socialism":
                sortedBars = [...allBars].sort(
                  (a, b) => a.weightedDistance - b.weightedDistance
                );
                break;
              case "communism":
                sortedBars = [...allBars].sort(
                  (a, b) => a.distanceVariance - b.distanceVariance
                );
                break;
              case "utilitarianism":
              default:
                sortedBars = [...allBars].sort(
                  (a, b) => a.totalDistance - b.totalDistance
                );
                break;
            }
            strategyResults[strategyName].bestBar = sortedBars[0];
            // store best first
            strategyResults[strategyName].candidates = sortedBars.slice(0, 20);
          });

          // switch view
          inputView.classList.add("hidden");
          mapView.classList.remove("hidden");

          initializeMap();

          addPeopleMarkers();

          const mapBounds = geocodedPeopleList.map((p) => [p.lat, p.lng]);
          map.fitBounds(mapBounds, { padding: [100, 100] });

          // run animation from worst candidate to best candidate
          const initialCandidates = strategyResults[initialStrategy].candidates;
          const initialColor = strategyResults[initialStrategy].color;

          // if no candidates then just show results instantly
          if (initialCandidates.length > 0) {
            // animate from last to first
            for (let i = initialCandidates.length - 1; i >= 0; i--) {
              const bar = initialCandidates[i];
              updateBestBarOnMap(bar, initialColor);
              const delayTime = i < 2 ? 150 : i < 7 ? 120 : 80;
              await delay(delayTime);
            }
          }

          // set current strategy and rank defaults
          currentStrategy = initialStrategy;
          currentRankIndex = 0;

          // reveal toggles and set styles
          strategyToggleContainer.classList.remove("hidden");
          showStrategyResults(currentStrategy);
          displayCandidate(currentStrategy, currentRankIndex);
        } catch (error) {
          console.error("Error finding midpoint:", error);
          showError(error.message);
        } finally {
          showLoading(false);
        }
      }

      function initializeMap() {
        if (map) {
          map.remove();
          map = null;
        }
        // default to zurich if no data
        map = L.map("map").setView([47.3769, 8.5417], 13);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "&copy; OpenStreetMap contributors",
        }).addTo(map);
        map.invalidateSize();
      }

      function clearMap() {
        for (const layer of mapLayers) {
          map.removeLayer(layer);
        }
        mapLayers.length = 0;

        for (const layer of dynamicMapLayers) {
          map.removeLayer(layer);
        }
        dynamicMapLayers.length = 0;
      }

      function addPeopleMarkers() {
        clearMap();
        peopleMarkers.length = 0;

        geocodedPeopleList.forEach((person) => {
          const icon = L.divIcon({
            className: "emoji-marker",
            html: `<div class="emoji-marker-bg">${person.emoji}</div>`,
            iconSize: [44, 44],
            iconAnchor: [22, 22],
          });

          const marker = L.marker([person.lat, person.lng], { icon })
            .addTo(map)
            .bindPopup(person.name);
          mapLayers.push(marker);
          peopleMarkers.push(marker);
        });
      }

      function updateBestBarOnMap(bar, color) {
        while (dynamicMapLayers.length > 0) {
          map.removeLayer(dynamicMapLayers.pop());
        }

        barName.textContent = bar.name;
        totalDistanceStat.textContent = `Total: ${bar.totalDistance.toFixed(
          2
        )} km`;
        weightedDistanceStat.textContent = `Weighted: ${bar.weightedDistance.toFixed(
          2
        )} km¬≤`;

        geocodedPeopleList.forEach((person) => {
          const line = L.polyline(
            [
              [person.lat, person.lng],
              [bar.lat, bar.lng],
            ],
            { color: color, weight: 3, opacity: 0.8, dashArray: "8, 8" }
          ).addTo(map);
          dynamicMapLayers.push(line);
        });

        const barIcon = L.divIcon({
          className: "emoji-marker emoji-marker-bar",
          html: "üçª",
          iconSize: [44, 44],
          iconAnchor: [22, 22],
        });

        const barMarker = L.marker([bar.lat, bar.lng], {
          icon: barIcon,
          zIndexOffset: 1000,
        }).addTo(map).bindPopup(`
                    <b>${bar.name}</b>
                    <br>Total Dist: ${bar.totalDistance.toFixed(2)} km
                    <br>Weighted: ${bar.weightedDistance.toFixed(2)} km¬≤
                    <br>Variance: ${bar.distanceVariance.toFixed(2)}
                `);

        dynamicMapLayers.push(barMarker);
      }

      function changeBarRank(direction) {
        const candidates = strategyResults[currentStrategy].candidates;
        if (!candidates.length) return;

        currentRankIndex += direction;

        // Clamp the index
        if (currentRankIndex < 0) currentRankIndex = 0;
        if (currentRankIndex >= candidates.length)
          currentRankIndex = candidates.length - 1;

        // Get the bar directly (no reversing needed)
        const bar = candidates[currentRankIndex];
        const color = strategyResults[currentStrategy].color;

        updateBestBarOnMap(bar, color);

        // Update the rank text
        if (currentRankIndex === 0) {
          barRank.textContent = "Best Location";
        } else {
          barRank.textContent = `${currentRankIndex + 1}. Best Location`;
        }
      }

      // show results for a strategy but do not change the rank index
      function showStrategyResults(strategyName) {
        currentStrategy = strategyName;
        currentRankIndex = 0;

        const { bestBar, candidates, color } = strategyResults[strategyName];
        if (!bestBar) return;

        // Update map with best bar (rank #1)
        updateBestBarOnMap(bestBar, color);
        barRank.textContent = "Best Location";

        // Highlight selected toggle button properly
        document.querySelectorAll(".strategy-toggle").forEach((button) => {
          if (button.dataset.strategy === strategyName) {
            button.style.backgroundColor = color;
            button.style.color = "white";
            button.classList.add("ring", "ring-offset-2");
          } else {
            button.style.backgroundColor = "#f3f4f6"; // gray-100
            button.style.color = "#374151"; // gray-700
            button.classList.remove("ring", "ring-offset-2");
          }
        });

        // Update the rest (person markers, popups)
        updatePeopleMarkerColors(bestBar);
        updatePeoplePopups(bestBar);
      }

      // displays candidate by index for given strategy
      function displayCandidate(strategyName, rankIndex) {
        const cands = strategyResults[strategyName].candidates;
        if (!cands || cands.length === 0) return;

        // ensure within bounds
        rankIndex = Math.max(0, Math.min(cands.length - 1, rankIndex));
        currentRankIndex = rankIndex;

        const bar = cands[rankIndex];
        const color = strategyResults[strategyName].color;

        updateBestBarOnMap(bar, color);
        updatePeopleMarkerColors(bar);
        updatePeoplePopups(bar);

        // find bar marker and open popup
        const barMarker = dynamicMapLayers.find(
          (layer) => layer.options && layer.options.zIndexOffset === 1000
        );
        if (barMarker) barMarker.openPopup();

        // update rank badge text, ranks shown as 1 is best

        if (currentRankIndex === 0) {
          barRank.textContent = "Best Location";
        } else {
          barRank.textContent = `${currentRankIndex + 1}. Best Location`;
        }
        
      }

      function updatePeopleMarkerColors(bestBar) {
        const distances = bestBar.individualDistances;
        if (!distances || distances.length === 0) return;

        const min = Math.min(...distances);
        const max = Math.max(...distances);
        const range = max - min;

        if (range === 0) {
          peopleMarkers.forEach((marker) => {
            const el = marker.getElement();
            if (!el) return;
            const bgDiv = el.querySelector(".emoji-marker-bg");
            if (bgDiv) bgDiv.style.backgroundColor = "hsl(120, 70%, 80%)";
          });
          return;
        }

        distances.forEach((dist, index) => {
          const marker = peopleMarkers[index];
          if (!marker) return;
          const normalized = (dist - min) / range;
          const hue = (1 - normalized) * 120;
          const el = marker.getElement();
          if (!el) return;
          const bgDiv = el.querySelector(".emoji-marker-bg");
          if (bgDiv) bgDiv.style.backgroundColor = `hsl(${hue}, 70%, 80%)`;
        });
      }

      function updatePeoplePopups(bestBar) {
        const distances = bestBar.individualDistances;
        if (!distances) return;

        distances.forEach((dist, index) => {
          const marker = peopleMarkers[index];
          const person = geocodedPeopleList[index];
          if (!marker || !person) return;

          marker.unbindPopup();
          marker.bindPopup(`
                    <b>${person.name}</b>
                    <br>Distance: ${dist.toFixed(2)} km
                `);
        });
      }

      function resetApp() {
        mapView.classList.add("hidden");
        inputView.classList.remove("hidden");
        strategyToggleContainer.classList.add("hidden");

        geocodedPeopleList = [];
        allBars = [];
        peopleMarkers.length = 0;

        barRank.textContent = "Best Location";
        currentRankIndex = 0;

        Object.keys(strategyResults).forEach((key) => {
          strategyResults[key].bestBar = null;
          strategyResults[key].candidates = [];
        });

        clearMap();
      }

      function showLoading(isLoading) {
        if (isLoading) {
          calculateButton.disabled = true;
          calcButtonText.classList.add("hidden");
          loadingSpinner.classList.remove("hidden");
        } else {
          calculateButton.disabled = false;
          calcButtonText.classList.remove("hidden");
          loadingSpinner.classList.add("hidden");
        }
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorModal.classList.remove("hidden");
      }

      async function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function haversineDistance(lat1, lon1, lat2, lon2) {
        if (lat1 === lat2 && lon1 === lon2) return 0;
        const R = 6371;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      async function geocodeLocation(query) {
        const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(
          query
        )}&limit=1`;

        const response = await fetch(url);
        if (!response.ok)
          throw new Error(`Network error while geocoding "${query}"`);
        const data = await response.json();
        if (!data.features || data.features.length === 0) return null;

        const name = data.features[0].properties.name;
        const { coordinates } = data.features[0].geometry;
        return {
          location: { lat: coordinates[1], lng: coordinates[0] },
          name,
        };
      }

      async function fetchBarsInBounds(bounds, restaurantsConsidered = false) {
        const overpassUrl = "https://overpass-api.de/api/interpreter";

        const locationTypes = ["bar", "pub"];
        if (restaurantsConsidered) locationTypes.push("restaurant");

        const boundsStr = `${bounds.south},${bounds.west},${bounds.north},${bounds.east}`;

        const query = `
                [out:json][timeout:100];
                (
                  ${locationTypes
                    .map((a) => `node["amenity"="${a}"](${boundsStr});`)
                    .join("\n  ")}
                );
                out body;
            `;

        const response = await fetch(overpassUrl, {
          method: "POST",
          body: query,
        });

        if (!response.ok)
          throw new Error(
            "Failed to fetch bars from OpenStreetMap (Overpass API). The server might be busy. Try again."
          );
        const data = await response.json();

        const bars = data.elements
          .filter((el) => el.tags && el.tags.name)
          .map((el) => ({
            name: el.tags.name,
            city: el.tags["addr:city"] || "",
            lat: el.lat,
            lng: el.lon,
          }));

        if (bars.length === 0) {
          throw new Error(
            "No bars, pubs, or restaurants found in the area. Try expanding your search or including restaurants."
          );
        }

        return bars;
      }
    </script>
  </body>
</html>
